addEventListener('fetch', event => {
  event.respondWith(handleRequest(event.request))
})

const TELEGRAM_BOT_TOKEN = '7703766321:AAHnfPzIHRAyFJ9YgMF_bzlywG6PUCyFkWM'
const TELEGRAM_API_URL = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}`
const FINISH_CELL = 96
const BOARD_ROWS = 12
const BOARD_COLS = 8

function generateSpecialSquares() {
  const specialSquares = {}
  const occupiedCells = new Set()

  for (let i = 0; i < 9; i++) {
    let start, end
    do {
      start = Math.floor(Math.random() * (FINISH_CELL - 20)) + 1
      const minJump = 5
      const maxJump = Math.min(20, FINISH_CELL - start)
      end = start + minJump + Math.floor(Math.random() * (maxJump - minJump + 1))
    } while (occupiedCells.has(start) || occupiedCells.has(end) || end > FINISH_CELL)
    specialSquares[start] = { type: 'ladder', to: end }
    occupiedCells.add(start)
    occupiedCells.add(end)
  }

  for (let i = 0; i < 17; i++) {
    let start, end
    do {
      start = Math.floor(Math.random() * (FINISH_CELL - 5)) + 6
      const minJump = 5
      const maxJump = Math.min(15, start - 1)
      end = start - (minJump + Math.floor(Math.random() * (maxJump - minJump + 1)))
    } while (occupiedCells.has(start) || occupiedCells.has(end) || end < 1)
    specialSquares[start] = { type: 'snake', to: end }
    occupiedCells.add(start)
    occupiedCells.add(end)
  }

  return specialSquares
}

function createGameBoard(playerPosition, botPosition, specialSquares) {
  let board = []
  for (let row = BOARD_ROWS; row >= 1; row--) {
    let rowButtons = []
    for (let col = 1; col <= BOARD_COLS; col++) {
      const cellNumber = (row - 1) * BOARD_COLS + (row % 2 === 0 ? BOARD_COLS - col + 1 : col)
      let buttonText = 'âšª'
      if (cellNumber === playerPosition) {
        buttonText = 'ğŸ§‘â€ğŸš€'
      } else if (cellNumber === botPosition) {
        buttonText = 'ğŸ‘¾'
      } else if (cellNumber === FINISH_CELL) {
        buttonText = 'ğŸ'
      } else if (specialSquares[cellNumber]) {
        buttonText = specialSquares[cellNumber].type === 'ladder' ? 'ğŸªœâ¬†ï¸' : 'ğŸâ¡ï¸'
      } else {
        buttonText = cellNumber.toString().padStart(2, ' ')
      }
      rowButtons.push({ text: buttonText, callback_data: `cell_${cellNumber}`, fixed_width: true })
    }
    board.push(rowButtons)
  }
  return board
}

function getGameStatus(gameState) {
  const playerPosition = gameState?.playerPosition || 0
  const botPosition = gameState?.botPosition || 0
  const moveCount = gameState?.moveCount || 0
  return `*ğŸ§‘â€ğŸš€ Ø´Ù…Ø§:* ${playerPosition} (ÙØ§ØµÙ„Ù‡ ØªØ§ Ù¾Ø§ÛŒØ§Ù†: ${FINISH_CELL - playerPosition})\n*ğŸ‘¾ Ø±Ø¨Ø§Øª:* ${botPosition} (ÙØ§ØµÙ„Ù‡ ØªØ§ Ù¾Ø§ÛŒØ§Ù†: ${FINISH_CELL - botPosition})\n*â³ Ù†ÙˆØ¨Øª:* ${gameState?.currentPlayer === 'player' ? 'Ø´Ù…Ø§' : 'Ø±Ø¨Ø§Øª'}\n*ğŸ¯ Ø­Ø±Ú©Øªâ€ŒÙ‡Ø§:* ${moveCount}`
}

async function handleRequest(request) {
  try {
    if (request.method !== 'POST') return new Response('OK')
    const update = await request.json()

    if (update.callback_query) {
      const chatId = update.callback_query.message.chat.id
      const messageId = update.callback_query.message.message_id
      const data = update.callback_query.data
      await answerCallbackQuery(update.callback_query.id)

      async function getGameState(chatId) {
        const state = await BOT_MAR.get(`game_${chatId}`, { type: 'json' })
        if (state && (Date.now() - state.lastActivity) > 90 * 1000) {
          await BOT_MAR.delete(`game_${chatId}`)
          return null
        }
        return state
      }

      async function setGameState(chatId, state) {
        state.lastActivity = Date.now()
        await BOT_MAR.put(`game_${chatId}`, JSON.stringify(state), { expirationTtl: 24 * 60 * 60 })
      }

      async function getScore(chatId) {
        const score = await BOT_MAR.get(`score_${chatId}`, { type: 'json' })
        return score || 0
      }

      async function setScore(chatId, newScore) {
        const currentScore = await getScore(chatId)
        await BOT_MAR.put(`score_${chatId}`, JSON.stringify(currentScore + newScore))
        await updateLeaderboard(chatId, newScore)
      }

      async function updateLeaderboard(chatId, score) {
        let leaderboard = await BOT_MAR.get('leaderboard', { type: 'json' }) || {}
        leaderboard[chatId] = (leaderboard[chatId] || 0) + score
        await BOT_MAR.put('leaderboard', JSON.stringify(leaderboard))
      }

      async function getLeaderboard() {
        const leaderboard = await BOT_MAR.get('leaderboard', { type: 'json' }) || {}
        return Object.entries(leaderboard)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 10)
          .map(([chatId, score], index) => `${index + 1}. Ú©Ø§Ø±Ø¨Ø± ${chatId}: ${score}`)
          .join('\n')
      }

      let state = await getGameState(chatId)

      if (data === 'play') {
        if (state) {
          await editMessageText(chatId, messageId, '*âš ï¸ Ø´Ù…Ø§ Ø¯Ø± Ø­Ø§Ù„ Ø­Ø§Ø¶Ø± Ø¯Ø± ÛŒÚ© Ø¨Ø§Ø²ÛŒ Ù‡Ø³ØªÛŒØ¯!*\nÙ„Ø·ÙØ§Ù‹ Ø¨Ø§Ø²ÛŒ ÙØ¹Ù„ÛŒ Ø±Ø§ Ø¨Ù‡ Ù¾Ø§ÛŒØ§Ù† Ø¨Ø±Ø³Ø§Ù†ÛŒØ¯.', [
            [{ text: 'ğŸ²', callback_data: 'roll' }]
          ], { parse_mode: 'Markdown' })
          return new Response('OK')
        }
        const specialSquares = generateSpecialSquares()
        state = { playerPosition: 0, botPosition: 0, diceRoll: null, currentPlayer: 'player', specialSquares, moveCount: 0 }
        await setGameState(chatId, state)
        await editMessageText(chatId, messageId, `*ğŸ² Ø¨Ø§Ø²ÛŒ Ø´Ø±ÙˆØ¹ Ø´Ø¯!*\n\n${getGameStatus(state)}`, [
          ...createGameBoard(0, 0, specialSquares),
          [{ text: 'ğŸ²', callback_data: 'roll' }]
        ], { parse_mode: 'Markdown' })
        return new Response('OK')
      }

      if (data === 'roll') {
        if (!state) {
          await editMessageText(chatId, messageId, '*âš ï¸ Ø¯ÛŒØªØ§ÛŒ Ø¨Ø§Ø²ÛŒ Ø´Ù…Ø§ Ù¾Ø§Ú© Ø´Ø¯Ù‡ Ø§Ø³Øª!*\nÙ„Ø·ÙØ§Ù‹ Ø¨Ø§Ø²ÛŒ Ø¬Ø¯ÛŒØ¯ÛŒ Ø´Ø±ÙˆØ¹ Ú©Ù†ÛŒØ¯.', [
            [{ text: 'â–¶ï¸ Ø¨Ø§Ø²ÛŒ Ø¬Ø¯ÛŒØ¯', callback_data: 'play' }],
            [{ text: 'ğŸ† Ø¬Ø¯ÙˆÙ„ Ø§Ù…ØªÛŒØ§Ø²Ø§Øª', callback_data: 'leaderboard' }]
          ], { parse_mode: 'Markdown' })
          return new Response('OK')
        }

        if (state.diceRoll) {
          await editMessageText(chatId, messageId, `*âš ï¸ Ø´Ù…Ø§ Ù‚Ø¨Ù„Ø§Ù‹ ØªØ§Ø³ Ø§Ù†Ø¯Ø§Ø®ØªÙ‡â€ŒØ§ÛŒØ¯!*\nÙ„Ø·ÙØ§Ù‹ Ø®Ø§Ù†Ù‡ Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯.\nğŸ² ØªØ§Ø³ Ø´Ù…Ø§: ${state.diceRoll}\n\n${getGameStatus(state)}`, [
            ...createGameBoard(state.playerPosition, state.botPosition, state.specialSquares),
            [{ text: 'ğŸ²', callback_data: 'roll' }]
          ], { parse_mode: 'Markdown' })
          return new Response('OK')
        }

        const diceRoll = Math.floor(Math.random() * 6) + 1
        state.diceRoll = diceRoll
        await setGameState(chatId, state)
        await editMessageText(chatId, messageId, `*ğŸ² ØªØ§Ø³ Ø´Ù…Ø§: ${diceRoll}*\nÙ„Ø·ÙØ§Ù‹ Ø±ÙˆÛŒ Ø®Ø§Ù†Ù‡â€ŒØ§ÛŒ Ú©Ù‡ Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡ÛŒØ¯ Ø­Ø±Ú©Øª Ú©Ù†ÛŒØ¯ Ú©Ù„ÛŒÚ© Ú©Ù†ÛŒØ¯.\n\n${getGameStatus(state)}`, [
          ...createGameBoard(state.playerPosition, state.botPosition, state.specialSquares),
          [{ text: 'ğŸ²', callback_data: 'roll' }]
        ], { parse_mode: 'Markdown' })
        return new Response('OK')
      }

      if (data === 'leaderboard') {
        const leaderboardText = await getLeaderboard()
        await editMessageText(chatId, messageId, `*ğŸ† Ø¬Ø¯ÙˆÙ„ Ø§Ù…ØªÛŒØ§Ø²Ø§Øª Ø¨Ø±ØªØ±:*\n${leaderboardText || 'Ù‡Ù†ÙˆØ² Ø§Ù…ØªÛŒØ§Ø²ÛŒ Ø«Ø¨Øª Ù†Ø´Ø¯Ù‡!'}\n\nØ§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯:`, [
          [{ text: 'â–¶ï¸ Ø¨Ø§Ø²ÛŒ Ø¬Ø¯ÛŒØ¯', callback_data: 'play' }],
          [{ text: 'ğŸ† ØªØ§Ø²Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø¬Ø¯ÙˆÙ„', callback_data: 'leaderboard' }]
        ], { parse_mode: 'Markdown' })
        return new Response('OK')
      }

      if (data.startsWith('cell_')) {
        if (!state) {
          await editMessageText(chatId, messageId, '*âš ï¸ Ø¯ÛŒØªØ§ÛŒ Ø¨Ø§Ø²ÛŒ Ø´Ù…Ø§ Ù¾Ø§Ú© Ø´Ø¯Ù‡ Ø§Ø³Øª!*\nÙ„Ø·ÙØ§Ù‹ Ø¨Ø§Ø²ÛŒ Ø¬Ø¯ÛŒØ¯ÛŒ Ø´Ø±ÙˆØ¹ Ú©Ù†ÛŒØ¯.', [
            [{ text: 'â–¶ï¸ Ø¨Ø§Ø²ÛŒ Ø¬Ø¯ÛŒØ¯', callback_data: 'play' }],
            [{ text: 'ğŸ† Ø¬Ø¯ÙˆÙ„ Ø§Ù…ØªÛŒØ§Ø²Ø§Øª', callback_data: 'leaderboard' }]
          ], { parse_mode: 'Markdown' })
          return new Response('OK')
        }

        const selectedCell = parseInt(data.split('_')[1])
        const currentPos = state.currentPlayer === 'player' ? state.playerPosition : state.botPosition
        const diceRoll = state.diceRoll
        const specialSquares = state.specialSquares

        if (state.currentPlayer === 'player' && currentPos + diceRoll > FINISH_CELL) {
          await editMessageText(chatId, messageId, `*âŒ Ø´Ù…Ø§ Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø¨ÛŒØ´ØªØ± Ø§Ø² Ø®Ø§Ù†Ù‡ ${FINISH_CELL} Ø­Ø±Ú©Øª Ú©Ù†ÛŒØ¯!*\nğŸ² ØªØ§Ø³ Ø´Ù…Ø§: ${diceRoll}\n\n${getGameStatus(state)}`, [
            ...createGameBoard(state.playerPosition, state.botPosition, specialSquares),
            [{ text: 'ğŸ²', callback_data: 'roll' }]
          ], { parse_mode: 'Markdown' })
          delete state.diceRoll
          state.currentPlayer = 'bot'

          const botDiceRoll = Math.floor(Math.random() * 6) + 1
          let newBotPosition = state.botPosition + botDiceRoll
          state.moveCount = (state.moveCount || 0) + 1

          if (newBotPosition > FINISH_CELL) {
            await editMessageText(chatId, messageId, `*ğŸ‘¾ Ø±Ø¨Ø§Øª Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¨ÛŒØ´ØªØ± Ø§Ø² Ø®Ø§Ù†Ù‡ ${FINISH_CELL} Ø­Ø±Ú©Øª Ú©Ù†Ø¯!*\nğŸ² ØªØ§Ø³ Ø±Ø¨Ø§Øª: ${botDiceRoll}\n\n${getGameStatus(state)}`, [
              ...createGameBoard(state.playerPosition, state.botPosition, specialSquares),
              [{ text: 'ğŸ²', callback_data: 'roll' }]
            ], { parse_mode: 'Markdown' })
            state.currentPlayer = 'player'
            await setGameState(chatId, state)
            return new Response('OK')
          }

          if (specialSquares[newBotPosition]) {
            newBotPosition = specialSquares[newBotPosition].to
          }

          state.botPosition = newBotPosition

          if (newBotPosition === FINISH_CELL) {
            let score = 100 - (state.moveCount || 0)
            await setScore(chatId, score)
            await sendMessage(chatId, `*ğŸ‘¾ Ø±Ø¨Ø§Øª Ø¨Ø±Ù†Ø¯Ù‡ Ø´Ø¯!*\nØ§Ù…ØªÛŒØ§Ø² Ø§ÛŒÙ† Ø¨Ø§Ø²ÛŒ: ${score}\nÙ…Ø¬Ù…ÙˆØ¹ Ø§Ù…ØªÛŒØ§Ø²Ø§Øª Ø´Ù…Ø§: ${await getScore(chatId)}\nØ¨Ø±Ø§ÛŒ Ø§Ø¯Ø§Ù…Ù‡ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯:`, [
              [{ text: 'â–¶ï¸ Ø¨Ø§Ø²ÛŒ Ø¬Ø¯ÛŒØ¯', callback_data: 'play' }],
              [{ text: 'ğŸ† Ø¬Ø¯ÙˆÙ„ Ø§Ù…ØªÛŒØ§Ø²Ø§Øª', callback_data: 'leaderboard' }]
            ], { parse_mode: 'Markdown' })
            await BOT_MAR.delete(`game_${chatId}`)
            return new Response('OK')
          }

          await editMessageText(chatId, messageId, `*ğŸ‘¾ Ø±Ø¨Ø§Øª Ø­Ø±Ú©Øª Ú©Ø±Ø¯!*\nğŸ² ØªØ§Ø³ Ø±Ø¨Ø§Øª: ${botDiceRoll}\n\n${getGameStatus(state)}`, [
            ...createGameBoard(state.playerPosition, newBotPosition, specialSquares),
            [{ text: 'ğŸ²', callback_data: 'roll' }]
          ], { parse_mode: 'Markdown' })
          state.currentPlayer = 'player'
          await setGameState(chatId, state)
          return new Response('OK')
        }

        if (selectedCell !== currentPos + diceRoll) {
          await editMessageText(chatId, messageId, `*âŒ Ø®Ø§Ù†Ù‡ Ø§Ù†ØªØ®Ø§Ø¨ÛŒ Ø´Ù…Ø§ Ø§Ø´ØªØ¨Ø§Ù‡ Ø§Ø³Øª!*\nØ¨Ø§ÛŒØ¯ Ø¯Ù‚ÛŒÙ‚Ø§Ù‹ ${diceRoll} Ø®Ø§Ù†Ù‡ Ø¨Ù‡ Ø¬Ù„Ùˆ Ø­Ø±Ú©Øª Ú©Ù†ÛŒØ¯.\nğŸ² ØªØ§Ø³ Ø´Ù…Ø§: ${diceRoll}\n\n${getGameStatus(state)}`, [
            ...createGameBoard(state.playerPosition, state.botPosition, specialSquares),
            [{ text: 'ğŸ²', callback_data: 'roll' }]
          ], { parse_mode: 'Markdown' })
          await setGameState(chatId, state)
          return new Response('OK')
        }

        if (state.currentPlayer === 'player') {
          state.playerPosition = selectedCell
        } else {
          state.botPosition = selectedCell
        }
        state.moveCount = (state.moveCount || 0) + 1
        delete state.diceRoll

        if (specialSquares[selectedCell]) {
          const newPosition = specialSquares[selectedCell].to
          if (state.currentPlayer === 'player') {
            state.playerPosition = newPosition
          } else {
            state.botPosition = newPosition
          }
          await editMessageText(chatId, messageId, `*ğŸ² ØªØ§Ø³ Ø´Ù…Ø§: ${diceRoll}*\n${specialSquares[selectedCell].type === 'ladder' ? 'ğŸªœâ¬†ï¸' : 'ğŸâ¡ï¸'} Ø´Ù…Ø§ Ø¨Ù‡ Ø®Ø§Ù†Ù‡ ${newPosition} Ù…Ù†ØªÙ‚Ù„ Ø´Ø¯ÛŒØ¯!\n\n${getGameStatus(state)}`, [
            ...createGameBoard(state.playerPosition, state.botPosition, specialSquares),
            [{ text: 'ğŸ²', callback_data: 'roll' }]
          ], { parse_mode: 'Markdown' })
        } else {
          await editMessageText(chatId, messageId, `*ğŸ² ØªØ§Ø³ Ø´Ù…Ø§: ${diceRoll}*\nØ´Ù…Ø§ Ø¨Ù‡ Ø®Ø§Ù†Ù‡ ${selectedCell} Ø­Ø±Ú©Øª Ú©Ø±Ø¯ÛŒØ¯!\n\n${getGameStatus(state)}`, [
            ...createGameBoard(state.playerPosition, state.botPosition, specialSquares),
            [{ text: 'ğŸ²', callback_data: 'roll' }]
          ], { parse_mode: 'Markdown' })
        }

        if (state.playerPosition === FINISH_CELL) {
          let score = 100 - (state.moveCount || 0)
          await setScore(chatId, score)
          await sendMessage(chatId, `*ğŸ† ØªØ¨Ø±ÛŒÚ©! Ø´Ù…Ø§ Ø¨Ø±Ù†Ø¯Ù‡ Ø´Ø¯ÛŒØ¯!*\nØ§Ù…ØªÛŒØ§Ø² Ø§ÛŒÙ† Ø¨Ø§Ø²ÛŒ: ${score}\nÙ…Ø¬Ù…ÙˆØ¹ Ø§Ù…ØªÛŒØ§Ø²Ø§Øª Ø´Ù…Ø§: ${await getScore(chatId)}\nØ¨Ø±Ø§ÛŒ Ø§Ø¯Ø§Ù…Ù‡ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯:`, [
            [{ text: 'â–¶ï¸ Ø¨Ø§Ø²ÛŒ Ø¬Ø¯ÛŒØ¯', callback_data: 'play' }],
            [{ text: 'ğŸ† Ø¬Ø¯ÙˆÙ„ Ø§Ù…ØªÛŒØ§Ø²Ø§Øª', callback_data: 'leaderboard' }]
          ], { parse_mode: 'Markdown' })
          await BOT_MAR.delete(`game_${chatId}`)
          return new Response('OK')
        }

        if (state.botPosition === FINISH_CELL) {
          let score = 100 - (state.moveCount || 0)
          await setScore(chatId, score)
          await sendMessage(chatId, `*ğŸ‘¾ Ø±Ø¨Ø§Øª Ø¨Ø±Ù†Ø¯Ù‡ Ø´Ø¯!*\nØ§Ù…ØªÛŒØ§Ø² Ø§ÛŒÙ† Ø¨Ø§Ø²ÛŒ: ${score}\nÙ…Ø¬Ù…ÙˆØ¹ Ø§Ù…ØªÛŒØ§Ø²Ø§Øª Ø´Ù…Ø§: ${await getScore(chatId)}\nØ¨Ø±Ø§ÛŒ Ø§Ø¯Ø§Ù…Ù‡ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯:`, [
            [{ text: 'â–¶ï¸ Ø¨Ø§Ø²ÛŒ Ø¬Ø¯ÛŒØ¯', callback_data: 'play' }],
            [{ text: 'ğŸ† Ø¬Ø¯ÙˆÙ„ Ø§Ù…ØªÛŒØ§Ø²Ø§Øª', callback_data: 'leaderboard' }]
          ], { parse_mode: 'Markdown' })
          await BOT_MAR.delete(`game_${chatId}`)
          return new Response('OK')
        }

        state.currentPlayer = state.currentPlayer === 'player' ? 'bot' : 'player'

        if (state.currentPlayer === 'bot') {
          const botDiceRoll = Math.floor(Math.random() * 6) + 1
          let newBotPosition = state.botPosition + botDiceRoll
          state.moveCount = (state.moveCount || 0) + 1

          if (newBotPosition > FINISH_CELL) {
            await editMessageText(chatId, messageId, `*ğŸ‘¾ Ø±Ø¨Ø§Øª Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¨ÛŒØ´ØªØ± Ø§Ø² Ø®Ø§Ù†Ù‡ ${FINISH_CELL} Ø­Ø±Ú©Øª Ú©Ù†Ø¯!*\nğŸ² ØªØ§Ø³ Ø±Ø¨Ø§Øª: ${botDiceRoll}\n\n${getGameStatus(state)}`, [
              ...createGameBoard(state.playerPosition, state.botPosition, specialSquares),
              [{ text: 'ğŸ²', callback_data: 'roll' }]
            ], { parse_mode: 'Markdown' })
            state.currentPlayer = 'player'
            await setGameState(chatId, state)
            return new Response('OK')
          }

          if (specialSquares[newBotPosition]) {
            newBotPosition = specialSquares[newBotPosition].to
          }

          state.botPosition = newBotPosition

          if (newBotPosition === FINISH_CELL) {
            let score = 100 - (state.moveCount || 0)
            await setScore(chatId, score)
            await sendMessage(chatId, `*ğŸ‘¾ Ø±Ø¨Ø§Øª Ø¨Ø±Ù†Ø¯Ù‡ Ø´Ø¯!*\nØ§Ù…ØªÛŒØ§Ø² Ø§ÛŒÙ† Ø¨Ø§Ø²ÛŒ: ${score}\nÙ…Ø¬Ù…ÙˆØ¹ Ø§Ù…ØªÛŒØ§Ø²Ø§Øª Ø´Ù…Ø§: ${await getScore(chatId)}\nØ¨Ø±Ø§ÛŒ Ø§Ø¯Ø§Ù…Ù‡ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯:`, [
              [{ text: 'â–¶ï¸ Ø¨Ø§Ø²ÛŒ Ø¬Ø¯ÛŒØ¯', callback_data: 'play' }],
              [{ text: 'ğŸ† Ø¬Ø¯ÙˆÙ„ Ø§Ù…ØªÛŒØ§Ø²Ø§Øª', callback_data: 'leaderboard' }]
            ], { parse_mode: 'Markdown' })
            await BOT_MAR.delete(`game_${chatId}`)
            return new Response('OK')
          }

          await editMessageText(chatId, messageId, `*ğŸ‘¾ Ø±Ø¨Ø§Øª Ø­Ø±Ú©Øª Ú©Ø±Ø¯!*\nğŸ² ØªØ§Ø³ Ø±Ø¨Ø§Øª: ${botDiceRoll}\n\n${getGameStatus(state)}`, [
            ...createGameBoard(state.playerPosition, newBotPosition, specialSquares),
            [{ text: 'ğŸ²', callback_data: 'roll' }]
          ], { parse_mode: 'Markdown' })
          state.currentPlayer = 'player'
        }

        await setGameState(chatId, state)
        return new Response('OK')
      }
    } else {
      const chatId = update.message.chat.id
      await sendMessage(chatId, '*ğŸ² Ø®ÙˆØ´ Ø¢Ù…Ø¯ÛŒØ¯!*\nØ¨Ø±Ø§ÛŒ Ø´Ø±ÙˆØ¹ Ø¨Ø§Ø²ÛŒ ÛŒØ§ Ø¯ÛŒØ¯Ù† Ø¬Ø¯ÙˆÙ„ Ø§Ù…ØªÛŒØ§Ø²Ø§Øª Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯:', [
        [{ text: 'â–¶ï¸ Ø¨Ø§Ø²ÛŒ Ø¬Ø¯ÛŒØ¯', callback_data: 'play' }],
        [{ text: 'ğŸ† Ø¬Ø¯ÙˆÙ„ Ø§Ù…ØªÛŒØ§Ø²Ø§Øª', callback_data: 'leaderboard' }]
      ], { parse_mode: 'Markdown' })
      return new Response('OK')
    }
  } catch (error) {
    console.error(error)
    return new Response('Ø®Ø·Ø§ÛŒ Ø¯Ø§Ø®Ù„ÛŒ', { status: 500 })
  }
}

async function sendMessage(chatId, text, replyMarkup = [], options = {}) {
  const response = await fetch(`${TELEGRAM_API_URL}/sendMessage`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      chat_id: chatId,
      text: text,
      reply_markup: { inline_keyboard: replyMarkup },
      ...options
    })
  })
  return response.json()
}

async function editMessageText(chatId, messageId, text, replyMarkup = [], options = {}) {
  const response = await fetch(`${TELEGRAM_API_URL}/editMessageText`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      chat_id: chatId,
      message_id: messageId,
      text: text,
      reply_markup: { inline_keyboard: replyMarkup },
      ...options
    })
  })
  return response.json()
}

async function answerCallbackQuery(callbackQueryId) {
  const response = await fetch(`${TELEGRAM_API_URL}/answerCallbackQuery`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      callback_query_id: callbackQueryId
    })
  })
  return response.json()
}
